import pygame
import random
import sys
import os

pygame.init()

WIDTH = 600
HEIGHT = 700
LINE_WIDTH = 4
TILE_SIZE = 100
TILE_MARGIN = 15
BOARD_SIZE = 4
FPS = 60

COLORS = {
    0: (205, 193, 180),
    3: (238, 228, 218),
    9: (237, 224, 200),
    27: (242, 177, 121),
    81: (245, 149, 99),
    243: (246, 124, 95),
    729: (246, 94, 59),
    2187: (237, 207, 114),
    6561: (237, 204, 97),
    'text': (119, 110, 101),
    'light_text': (249, 246, 242),
    'background': (187, 173, 160),
    'grid_lines': (0, 0, 0),
    'cell_bg': (205, 193, 180),
    'overlay': (238, 228, 218, 150)
}

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("6561")
clock = pygame.time.Clock()
font = pygame.font.Font(None, 48)
small_font = pygame.font.Font(None, 32)

BOARD_WIDTH = BOARD_SIZE * TILE_SIZE + (BOARD_SIZE - 1) * TILE_MARGIN
BOARD_HEIGHT = BOARD_WIDTH
BOARD_X = (WIDTH - BOARD_WIDTH) // 2
BOARD_Y = (HEIGHT - BOARD_HEIGHT) // 2

class Game2048:
    def __init__(self):
        self.load_sprites()
        self.reset_game()
    
    def load_sprites(self):
        self.sprites = {}
        sprite_values = [3, 9, 27, 81, 243, 729, 2187, 6561]
        for value in sprite_values:
            try:
                sprite_path = os.path.join('assets', f'block{value}.png')
                print(f"Попытка загрузить: {sprite_path}")
                sprite = pygame.image.load(sprite_path)
                sprite = pygame.transform.scale(sprite, (TILE_SIZE, TILE_SIZE))
                self.sprites[value] = sprite
            except (pygame.error, FileNotFoundError) as e:
                self.sprites[value] = None
    
    def reset_game(self):
        self.board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
        self.score = 0
        self.game_over = False
        self.won = False
        self.add_new_tile()
        self.add_new_tile()
    
    def add_new_tile(self):
        empty_cells = []
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if self.board[i][j] == 0:
                    empty_cells.append((i, j))
        
        if empty_cells:
            i, j = random.choice(empty_cells)
            self.board[i][j] = 3 if random.random() < 0.9 else 9
    
    def compress(self, row):
        new_row = [0] * BOARD_SIZE
        pos = 0
        for i in range(BOARD_SIZE):
            if row[i] != 0:
                new_row[pos] = row[i]
                pos += 1
        return new_row
    
    def merge(self, row):
        score_add = 0
        for i in range(BOARD_SIZE - 1):
            if row[i] != 0 and row[i] == row[i + 1]:
                row[i] *= 3
                row[i + 1] = 0
                score_add += row[i]
        return row, score_add
    
    def move_left(self):
        moved = False
        score_add = 0
        for i in range(BOARD_SIZE):
            original = self.board[i].copy()
            new_row = self.compress(self.board[i])
            merged_row, add = self.merge(new_row)
            score_add += add
            final_row = self.compress(merged_row)
            if original != final_row:
                moved = True
            self.board[i] = final_row
        return moved, score_add
    
    def move_right(self):
        moved = False
        score_add = 0
        for i in range(BOARD_SIZE):
            original = self.board[i].copy()
            reversed_row = self.board[i][::-1]
            compressed = self.compress(reversed_row)
            merged, add = self.merge(compressed)
            score_add += add
            final = self.compress(merged)
            self.board[i] = final[::-1]
            if original != self.board[i]:
                moved = True
        return moved, score_add
    
    def move_up(self):
        moved = False
        score_add = 0
        for j in range(BOARD_SIZE):
            column = [self.board[i][j] for i in range(BOARD_SIZE)]
            original = column.copy()
            compressed = self.compress(column)
            merged, add = self.merge(compressed)
            score_add += add
            final = self.compress(merged)
            if original != final:
                moved = True
            for i in range(BOARD_SIZE):
                self.board[i][j] = final[i]
        return moved, score_add
    
    def move_down(self):
        moved = False
        score_add = 0
        for j in range(BOARD_SIZE):
            column = [self.board[i][j] for i in range(BOARD_SIZE - 1, -1, -1)]
            original = column.copy()
            compressed = self.compress(column)
            merged, add = self.merge(compressed)
            score_add += add
            final = self.compress(merged)
            if original != final:
                moved = True
            for i in range(BOARD_SIZE):
                self.board[BOARD_SIZE - 1 - i][j] = final[i]
        return moved, score_add
    
    def check_game_over(self):
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if self.board[i][j] == 6561:
                    self.won = True
                    return True
        
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if self.board[i][j] == 0:
                    return False
        
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE - 1):
                if self.board[i][j] == self.board[i][j + 1]:
                    return False
        
        for i in range(BOARD_SIZE - 1):
            for j in range(BOARD_SIZE):
                if self.board[i][j] == self.board[i + 1][j]:
                    return False
        
        return True
    
    def get_tile_color(self, value):
        return COLORS.get(value, (60, 58, 50))
    
    def get_text_color(self, value):
        if value <= 81:
            return COLORS['text']
        return COLORS['light_text']

def draw_grid():
    screen.fill(COLORS['background'])
    
    score_text = small_font.render(f"Счет: {game.score}", True, (255, 255, 255))
    score_rect = score_text.get_rect(center=(WIDTH // 2, 30))
    screen.blit(score_text, score_rect)
    
    start_x = BOARD_X
    start_y = BOARD_Y
    
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            x = start_x + col * (TILE_SIZE + TILE_MARGIN)
            y = start_y + row * (TILE_SIZE + TILE_MARGIN)
            pygame.draw.rect(screen, COLORS['cell_bg'], 
                           (x, y, TILE_SIZE, TILE_SIZE), border_radius=8)
    
    for i in range(BOARD_SIZE + 1):
        x = start_x + i * (TILE_SIZE + TILE_MARGIN) - TILE_MARGIN // 2
        pygame.draw.line(screen, COLORS['grid_lines'], 
                        (x, start_y - TILE_MARGIN // 2), 
                        (x, start_y + BOARD_HEIGHT + TILE_MARGIN // 2), 
                        LINE_WIDTH)
    
    for i in range(BOARD_SIZE + 1):
        y = start_y + i * (TILE_SIZE + TILE_MARGIN) - TILE_MARGIN // 2
        pygame.draw.line(screen, COLORS['grid_lines'], 
                        (start_x - TILE_MARGIN // 2, y), 
                        (start_x + BOARD_WIDTH + TILE_MARGIN // 2, y), 
                        LINE_WIDTH)

def draw_tiles():
    start_x = BOARD_X
    start_y = BOARD_Y
    
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            value = game.board[row][col]
            if value != 0:
                x = start_x + col * (TILE_SIZE + TILE_MARGIN)
                y = start_y + row * (TILE_SIZE + TILE_MARGIN)
                
                if value in game.sprites and game.sprites[value] is not None:
                    screen.blit(game.sprites[value], (x, y))
                else:
                    pygame.draw.rect(screen, game.get_tile_color(value), 
                                   (x, y, TILE_SIZE, TILE_SIZE), border_radius=8)
                    text = font.render(str(value), True, game.get_text_color(value))
                    text_rect = text.get_rect(center=(x + TILE_SIZE // 2, y + TILE_SIZE // 2))
                    screen.blit(text, text_rect)

def draw_game_over():
    if game.game_over or game.won:
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill(COLORS['overlay'])
        screen.blit(overlay, (0, 0))
        
        if game.won:
            text = font.render("ПОБЕДА! 6561", True, (0, 128, 0))
            subtext = small_font.render("Нажмите R для новой игры", True, (0, 0, 0))
        else:
            text = font.render("ИГРА ОКОНЧЕНА", True, (255, 0, 0))
            subtext = small_font.render("Нажмите R для новой игры", True, (0, 0, 0))
        
        text_rect = text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 20))
        subtext_rect = subtext.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 20))
        
        screen.blit(text, text_rect)
        screen.blit(subtext, subtext_rect)

if not os.path.exists('assets'):
    print("Папка 'assets' не найдена")

game = Game2048()

running = True
while running:
    clock.tick(FPS)
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_r:
                game.reset_game()
            
            if not game.game_over and not game.won:
                moved = False
                score_add = 0
                
                if event.key == pygame.K_LEFT:
                    moved, score_add = game.move_left()
                elif event.key == pygame.K_RIGHT:
                    moved, score_add = game.move_right()
                elif event.key == pygame.K_UP:
                    moved, score_add = game.move_up()
                elif event.key == pygame.K_DOWN:
                    moved, score_add = game.move_down()
                
                if moved:
                    game.score += score_add
                    game.add_new_tile()
                    game.game_over = game.check_game_over()
    
    draw_grid()
    draw_tiles()
    draw_game_over()
    
    pygame.display.flip()

pygame.quit()
sys.exit()
